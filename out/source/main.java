/* autogenerated by Processing revision 1282 on 2022-04-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {

GameEngine gE;
GameSettings gameSettings;

public final FVector MOVELEFT   = new FVector( -1f,  0f );
public final FVector MOVERIGHT  = new FVector(  1f,  0f );
public final FVector MOVEUP     = new FVector(  0f, -1f );
public final FVector MOVEDOWN   = new FVector(  0f,  1f );
public final FVector MOVENONE   = new FVector(  0f,  0f );

int countDown = 0;
long lastMillis;
boolean restart = false;

 public void settings(){
    //size( 600, 600 );
    fullScreen( 2 );
    noSmooth();
}

 public void setup(){
    frameRate( 80 );

    gameSettings = new GameSettings();

    gE = new GameEngine();

    lastMillis = millis();
}

 public void draw(){
    background( gameSettings.BACKCOLOR );

    if( millis() - lastMillis >= 800 && restart ){
            gE = new GameEngine();
            restart = false;
    }

    if( !gE.Quit() ){
        gE.UpdateGame();
    }
}

 public float Lerp( float a, float b, float t ){
    return a + t *( b - a );
}

 public void keyPressed(){
    if( !gE.GameOver() ){
        if( key == 'k'  ){
            gE.AddSnakeBody();
        }
        if( key == 'p' ){
            gE.TogglePause();
        }
        if( key == CODED ){
            if( keyCode == LEFT ){
                gE.TurnSnakeLeft();
            }
            if( keyCode == RIGHT ){
                gE.TurnSnakeRight();
            }
        }
    }
    else if( key == 'r' ){
        restart = true;
        lastMillis = millis();
    }
}
class FVector{
  public float x, y;

  // SVector default CONSTRUCTOR
  public FVector(){
    this.x = 0f;
    this.y = 0f;
  }

  // SVector CONSTRUCTOR
  public FVector( float x, float y ){
    this.x = x;
    this.y = y;
  }

  public FVector( int x, int y ){
    this.x = PApplet.parseFloat( x );
    this.y = PApplet.parseFloat( y );
  }



  //  ----  ----    COMMON OPERATIONS   ----  ----
  // Set
  public void Set( float x, float y ){                                          // Sets the coordinates to the gives coordinates.
    this.x = x;
    this.y = y;
  }
  public void Set( FVector vector ){                                            // Sets the coordinates to that of a given vector.
    Set( vector.x, vector.y );
  }

  // Add methods

  /**
  @param x '-,
  Adds this x coordinate to the vector.'
  @param y 'Adds this y coordinate to the vector.'
   */
  public void Add( float x, float y ){                                          // Adds the given x and y coordinates to the vector.
    this.x += x;
    this.y += y;
  }
  public void Add( FVector vector ){                                            // Adds the given vector.
    Add( vector.x, vector.y );
  }

  // Subtract methods
  public void Subtract( float x, float y ){                                     // Subtracts the vector by x and y coordinates.
    this.x -= x;
    this.y -= y;
  }
  public void Subtract( FVector vector ){                                        // Subtracts the vector by the inputed vector.
    Subtract( vector.x, vector.y );
  }

  // Multiply method
  public void Multiply( float d ){                                              // Multiplies the vector by d.
    this.x *= d;
    this.y *= d;
  }

  // Divide method
  public void Divide( float d ){                                                // Divides the vector by d.
    this.x /= d;
    this.y /= d;
  }

  // Project
  public void Project( FVector vector ){                                        // Projects vector onto another given vector.
    float d = GetScalarProduct( vector ) / ( vector.GetMagnitude() * vector.GetMagnitude() );
    Set( FVectorMath.Multiply( vector, d ) );
  }

  // Normalize
  public void Normalize(){
    if      ( this.x < -1f ){ this.x = -1; }
    else if ( this.x >  1f ){ this.x =  1; }
    else                    { this.x =  0; }

    if      ( this.y < -1f ){ this.y = -1; }
    else if ( this.y >  1f ){ this.y =  1; }
    else                    { this.y =  0; }
  }



  //  ----  ----    RETURN METHODS    ----  ---
  // Angle
  public float GetAngle(){
    return atan( y / x );
  }


  // Magnitudes
  public float GetMagnitude(){                                                  // Returns the magnitude (length) of the vector.
    return sqrt( this.x * this.x + this.y * this.y );
  }

  // Scalar products
  public float GetScalarProduct( FVector vector ){                              // Returns the scalar product of this vector and a second vector.
    if( GetMagnitude() == 0f || vector.GetMagnitude() == 0f ){
      return 0f;
    }
    
    return x*vector.x + y*vector.y;
  }

  public FVector ReturnNewInstance(){                                           // Returns a new instance of an FVector with the same x and y coordinates.
    return new FVector( x, y );
  }
  public float[] GetVector(){                                                   // Returns both x and y positions as a float array.
    float[] vectors = { x, y };
    return vectors;
  }
  
  public boolean IsTheSame( FVector vector ){                                   // Returns true if the given vector is the same as this vector.
    if( x == vector.x && y == vector.y ){ return true; }
    return false;
  }


  // String override
  public String toString(){
    return "( " + x +  ", " + y + " )";
  }
}
interface IntPhysicsBody{
  public void UpdatePhysics();
}
abstract class Entity{
    protected FVector position;
    protected String name;

    // Entity CONSTRUCTOR
    public Entity( String name, int x, int y ){
        this.name = name;
        this.position = new FVector();

        // Checks validity of column variable.
        if( x >= 0 ){
            if( x < gameSettings.playAreaResolution ){
                this.position.x = PApplet.parseFloat(x);
            }
            else{
                IllegalArgumentSmaller( x );
            }
        }
        else{
            IllegalArgumentLarger( x );
        }

        // Checks validity of row variable.
        if( y >= 0 ){
            if( y < gameSettings.playAreaResolution ){
                this.position.y = PApplet.parseFloat(y);
            }
            else{
                IllegalArgumentSmaller( y );
            }
        }
        else{
            IllegalArgumentLarger( y );
        }
    }

    // Abstract method for drawing the entity.
    abstract public void Draw( int frame );

    // Draws a sprite at the correct position, orientation.
    protected void DrawSprite( FVector position, float scale, float rotation, PImage sprite, boolean flip ){    // Draws a snake block.
        float sS = gameSettings.squareSize;

        pushMatrix();

        float x = gameSettings.IndexToPosition( position.x ) + sS/2f;
        float y = gameSettings.IndexToPosition( position.y ) + sS/2f;
        translate( x, y );

        // Drawing the sprite
        scale( scale, scale );
        if( flip ){ scale( -1, 1 ); }
        rotate( rotation );
        image( sprite, -sS/2f, -sS/2f, sS,sS );

        popMatrix();
    }

    // Properties
    public String   GetName()       { return this.name; }
    public FVector  GetPosition()   { return this.position.ReturnNewInstance(); }
    public float    GetX()          { return this.position.x; }
    public float    GetY()          { return this.position.y; }

    // Exceptions
    private void IllegalArgumentSmaller( int a ){
        throw new IllegalArgumentException( this.name + " must have a column (" + a + ") smaller than the play area." );
    }

    private void IllegalArgumentLarger( int a ){
        throw new IllegalArgumentException( this.name + " must have a row (" + a + ") at 0 or larger." );
    }

    abstract public String toString();
}
class Entity_Fruit extends Entity{
    private final String[] spriteNames = { "appleIdle", "bananaIdle", "strawberryIdle" };
    private PImage[] sprites;
    private Sprite sprite;

    // Entity_Snake CONSTRUCTOR
    public Entity_Fruit( String name, int x, int y ){
        super( name, x, y );                            // Sending arguments to inherited class.

        int a = PApplet.parseInt( random( this.spriteNames.length ) );    // Choosing a random sprite.
        this.sprite = new Sprite( "fruits", this.spriteNames[a] );
    }
    
    public void Draw( int frame ){
        this.sprite.DrawSprite( frame, this.position, 0.95f, 0f, false );
    }


    // Returns a string to explain the object.
    public String toString(){
        return this.name + " (Entity_Fruit), " + "pos : ( " + this.position.x + ", " + this.position.y + " ), ";
    }
}
class Entity_Snake extends Entity implements IntPhysicsBody{
    private ArrayList<FVector> chain;
    private FVector lastPosition;
    private FVector velocity;
    private int gridSize;

    // Flags
    private boolean velocityLock = false;
    private boolean addSnakeBody = false;

    private String[] spriteNames = {
        "snakeHeadMoving",
        "snakeHeadTrans",
        "snakeHeadTurningTrans",
        "snakeBodyMoving",
        "snakeBodyTurning", 
        "snakeTailTurning",
        "snakeTailMoving", 
        "snakeTailTrans",
        "snakeTurningArrow"
    };
    private ArrayList<Sprite> sprites;
    private float tailAlpha = 0;
    private float headAlpha = 245;

    // Entity_Snake CONSTRUCTOR     #region [CONSTRUCTOR]
    public Entity_Snake( String name, int x, int y, FVector velocity ){
        super( name, x, y );
        this.lastPosition   = new FVector();
        this.velocity       = new FVector();
        this.velocity.Set( velocity );
        
        // Setting up snake chain
        this.chain = new ArrayList<FVector>();
        for( int i = 1; i <= 3; i++ ){
            this.chain.add( new FVector( x + i, y ) );
        }
        this.gridSize = gameSettings.playAreaResolution;

        // Setting up sprites
        this.sprites = new ArrayList<Sprite>();
        for( int i = 0; i < this.spriteNames.length; i++ ){
            this.sprites.add( new Sprite( "snake", this.spriteNames[ i ] ) );
        }
    }    //#endregion


    //  ----    ----    PHYSICSENGINE FUNCTIONALITIES   ----    ----
    // Main method updating entities physics for the physics engine.    #region [UpdatePhysics]  
    public void UpdatePhysics(){
        this.lastPosition = position.ReturnNewInstance();
        LoopMovement( gameSettings.LoopMovement() );
        this.position.Add( this.velocity );
        this.chain.add( 0, this.lastPosition );
        this.chain.remove( this.chain.size() - 1 );
        
        this.velocityLock = false;
        this.addSnakeBody = false;
    }   //#endregion


    // Loops the movement of the snake around the play area.
    public void LoopMovement( boolean toggle ){
        if( toggle ){
            if( this.position.x <= 0f && this.velocity.x < 0f ){
                this.position.x += this.gridSize;
            }
            if( this.position.y <= 0f && this.velocity.y < 0f ){
                this.position.y += this.gridSize;
            }
            if( this.position.x >= ( this.gridSize - 1 ) && this.velocity.x > 0f ){
                this.position.x -= this.gridSize;
            }
            if( this.position.y >= ( this.gridSize - 1 ) && this.velocity.y > 0f ){
                this.position.y -= this.gridSize;
            }
        }
    }

    // Turns the snake its oriented left.
    public void UpdateVelocityLeft(){
        if( !velocityLock ){ 
            velocity.Set( ReturnVectorOrientedLeft( velocity ) );
            velocityLock = true;
            
            // Adding a snakeArrow
            FVector neckVelocity = CalculateNeckVelocity();
        
            // Draws the arrows when the head turns
            FVector left = ReturnVectorOrientedLeft( neckVelocity );
            FVector position = this.position.ReturnNewInstance();
            position.Add( ReturnVectorOrientedLeft( neckVelocity ) );
            gE.AddSprite( new Entity_Sprite(
                "Arrow Left",
                PApplet.parseInt(position.x), PApplet.parseInt(position.y),
                "snake", "snakeTurningArrow",
                ReturnRotation( left )
                )
            );
        }
    }

    // Turns the snake its oriented left.
    public void UpdateVelocityRight(){
        if( !this.velocityLock ){
            this.velocity.Set( ReturnVectorOrientedRight( this.velocity ) );
            this.velocityLock = true;

            // Adding a snake arrow
            FVector neckVelocity = CalculateNeckVelocity();
        
            // Draws the arrows when the head turns
            FVector right = ReturnVectorOrientedRight( neckVelocity );
            FVector position = this.position.ReturnNewInstance();
            position.Add( ReturnVectorOrientedRight( neckVelocity ) );
            gE.AddSprite( new Entity_Sprite(
                "Arrow Right",
                PApplet.parseInt(position.x), PApplet.parseInt(position.y),
                "snake", "snakeTurningArrow",
                ReturnRotation( right )
                )
            );
        }
    }


    //  ----    ----    PAINTENGINE FUNCTIONALITIES     ----    ----
    // Main method for updating entity drawings for the paint engine.   #region [Draw]
    public void Draw( int frame ){
        int     clock           = gameSettings.GameClockRate();
        FVector neckVelocity    = CalculateNeckVelocity();

        // Draws the body
        for( int i = this.chain.size() - 1; i >= 0; i-- ){
            String sprite       = "snakeBodyMoving";                // Default sprite for animation as most chains are normal moving snake sprites.
            boolean flip        = false;                            // Flips the canvas in certain situations. DEFAULT is off.
            FVector velocity    = new FVector();                    // Useful so we can keep track of where this chain is heading next.
            float rotation;                                         // Will be used to rotate the grid depending on the orientation of the chain.

            // Setting velocity between chains to figure out sprite rotation.
            if( i == 0 ){
                velocity    = FVectorMath.Subtract( this.position, this.chain.get( 0 ) );    // Subtracting with the heads position to get the velocity to the head
                sprite      = "snakeHeadTrans";

            }
            else{ velocity  = FVectorMath.Subtract( this.chain.get( i - 1 ), this.chain.get( i ) ); }
            
            if( i + 2 == this.chain.size() ){
                sprite = "snakeTailTrans";
            }

            velocity = gameSettings.CorrectFVector( velocity );
            rotation = ReturnRotation( velocity );

            // Deciding which sprites to use.
            if( i + 1 < this.chain.size() && i >= 0 ){
                // Checking if this is the neck, so that the nextVelocity will be torwards the head in that case.
                FVector nextBlock;
                if( i == 0 ){ nextBlock = this.position.ReturnNewInstance(); }
                else        { nextBlock = this.chain.get( i - 1 ); }

                // Setting velocities to tell orientation and if we are turning.
                FVector nextVelocity    = FVectorMath.Subtract( nextBlock, this.chain.get( i ) );
                nextVelocity            = gameSettings.CorrectFVector( nextVelocity );
                FVector prevVelocity    = FVectorMath.Subtract( this.chain.get( i ), this.chain.get( i + 1 ) );
                prevVelocity            = gameSettings.CorrectFVector( prevVelocity );

                // Checking if the current chain is in a corner junction
                if( !nextVelocity.IsTheSame( prevVelocity ) ){
                    if( nextVelocity.IsTheSame( ReturnVectorOrientedLeft(  prevVelocity ) ) ){    // If we are turning left
                        flip = true;

                        if      ( prevVelocity.IsTheSame( MOVEUP ) )    { rotation = 0f; }
                        else if ( prevVelocity.IsTheSame( MOVEDOWN ) )  { rotation = PI; }
                    }
                    else if ( nextVelocity.IsTheSame( ReturnVectorOrientedRight( prevVelocity ) ) ){    // If we are turning right
                        flip = false; 
                    }

                    sprite = "snakeBodyTurning";              // Sets the default sprite to the turning sprite.
                    if( i == 0 ){                                       // If this chain is right on the neck, then we set it to a turning head sprite.
                        sprite = "snakeHeadTurningTrans";
                    }
                    else if( i + 2 == chain.size() ){                   // Else if its a chain right before the tail, we set it to a turning tail sprite.
                        sprite = "snakeTailTurning";
                    }
                }
            }

            if( i + 1 == this.chain.size() ){ sprite = "snakeTailMoving"; }        // Setting the tail sprite last so it overrides anything else.

            if( i == this.chain.size() - 1 && this.addSnakeBody ){
                this.tailAlpha = Lerp( this.tailAlpha, 255, 0.1f );
                tint( 0xFFFFBF46, this.tailAlpha );
            }
            else if( gE.GameOver() ){
                tint( 0xFFCC3363, this.headAlpha ); 
            }
            else{
                noTint();
            }

            for( Sprite s : this.sprites ){
                if( s.SpriteName() == sprite ){
                    s.DrawSprite( frame, this.chain.get( i ), 1f, rotation, flip );
                    fill( 255, 0, 0, 120 );
                }
            }
        }
        
        if( gE.GameOver() ){
            this.headAlpha = Lerp( this.headAlpha, 0, 0.2f);
            tint( 0xFFCC3363, this.headAlpha );
        }

        this.sprites.get( 0 ).DrawSprite( frame, this.position, 1f, ReturnRotation( gameSettings.CorrectFVector( neckVelocity ) ), false );
        /**rect( this.position.x * gameSettings.squareSize, 
                    this.position.y * gameSettings.squareSize, 
                    gameSettings.squareSize, gameSettings.squareSize );*/
    }   //#endregion

    // RETURN METHODS
    public boolean HeadCollision(){
        for( int i = 0; i < this.chain.size() - 1; i++ ){
            if( this.position.IsTheSame( this.chain.get( i ) ) ){
                return true;
            }
        }
        if( !gameSettings.LoopMovement() && !gameSettings.OutOfBounds( new FVector( 0, 0 ), new FVector( 9, 9 ), this.position ) ){
            return true;
        }
        return false;
    }

    public boolean DoesCollideSnake( FVector vector ){
        for( FVector v : this.chain ){
            if( vector.IsTheSame( v ) ){
                return true;
            }
        }
        if( this.position.IsTheSame( vector ) ){
            return true;
        }
        return false;
    }

    // Method for getting rotation value depending on direction
    private float ReturnRotation( FVector vector ){
        if      ( vector.IsTheSame( MOVERIGHT ) )    { return 0f; }
        else if ( vector.IsTheSame( MOVELEFT ) )     { return PI; }
        else if ( vector.IsTheSame( MOVEUP ) )       { return -HALF_PI; }
        else if ( vector.IsTheSame( MOVEDOWN ) )     { return HALF_PI; }
        else                                         { return 0; }
    }
    
    // Returns a vector oriented left of this vector.
    private FVector ReturnVectorOrientedLeft( FVector vector ){
        if      ( vector.IsTheSame( MOVEUP ) )      { return MOVELEFT; }
        else if ( vector.IsTheSame( MOVEDOWN ) )    { return MOVERIGHT; }
        else if ( vector.IsTheSame( MOVELEFT ) )    { return MOVEDOWN; }
        else if ( vector.IsTheSame( MOVERIGHT ) )   { return MOVEUP; }
        else                                        { return MOVENONE; }
    }

    // Returns a vector oriented right of this vector.
    private FVector ReturnVectorOrientedRight( FVector vector ){
        if      ( vector.IsTheSame( MOVEUP ) )      { return MOVERIGHT; }
        else if ( vector.IsTheSame( MOVEDOWN ) )    { return MOVELEFT; }
        else if ( vector.IsTheSame( MOVELEFT ) )    { return MOVEUP; }
        else if ( vector.IsTheSame( MOVERIGHT ) )   { return MOVEDOWN; }
        else                                        { return MOVENONE; }
    }

    private FVector CalculateNeckVelocity(){
        return FVectorMath.Subtract( this.position, this.chain.get( 0 ) );
    }
    
    //  ----    ----    SNAKE FUNCTIONALITIES   ----    ----
    public void AddToSnakeBody(){
        int i = this.chain.size() - 1;

        FVector newChain = this.chain.get( i ).ReturnNewInstance();
        newChain.Multiply( 2f );
        newChain.Subtract( this.chain.get( i - 1 ) );

        this.chain.add( newChain );
        
        this.tailAlpha = 0;
        this.addSnakeBody = true;
    }


    // Returns a string describing the object.
    public String toString(){
        return this.name + " (Entity_Snake), " + "pos : "   + this.position + ", " + "vel : " + this.velocity + ".";
    }
}
class Entity_Sprite extends Entity{
    private Sprite  sprite;
    private float   rotation; 
    private long    lastUpdate;
    
    // Pre-set variables
    private boolean expired     = false;
    private int     clock       = gameSettings.GameClockRate();
    private int     frame       = 1;
    

    // Entity_Sprite CONSTRUCTOR
    public Entity_Sprite( String name, int x, int y, String spriteDirectory, String spriteName, float rotation ){
        super( name, gameSettings.CorrectInt( x ), gameSettings.CorrectInt( y ) );

        this.sprite     = new Sprite( spriteDirectory, spriteName );
        this.rotation   = rotation;

        this.lastUpdate = millis();
    }

    // Entity_Sprite CONSTRUCTOR with a clock
    public Entity_Sprite( String name, int x, int y, String spriteDirectory, String spriteName, float rotation, int clock ){
        super( name, gameSettings.CorrectInt( x ), gameSettings.CorrectInt( y ) );

        this.sprite     = new Sprite( spriteDirectory, spriteName );
        this.rotation   = rotation;
        this.clock      = clock;

        this.lastUpdate = millis();
    }

    /**
     Draws the sprites entity with its own frame count.
    */
    public void Draw( int frame ){
        long dLastUpdate    = millis() - this.lastUpdate;
        if( dLastUpdate >= clock ){                             // Expires the sprite if an amount of time has gone
            this.expired = true;
            return;
        }

        float clockCycle = dLastUpdate / PApplet.parseFloat(gameSettings.GameClockRate());

        this.frame = ceil( gameSettings.frames * clockCycle ); 
        if( this.frame <= 0 || this.frame > 5){ this.frame = 1; }
        
        sprite.DrawSprite( this.frame, this.position, 0.9f, this.rotation, false );
    }

    /**
     Returns the current status of this sprite. If expired, this sprite will be destroyed.
    */
    public boolean IsExpired(){
        return this.expired;
    }

    public String toString(){
        return name + "(Entity_Sprite), pos : " + position + ".";
    }
}
static class FVectorMath{
  
  //  ----  ----  BASIC OPERATIONS  ----  ----
  // Addition
   public static FVector Add( FVector vector1, FVector vector2 ){                       // Returns the addition of vector1 and vector 2.
    FVector newVector = vector1.ReturnNewInstance();
    newVector.Add( vector2 );
    return newVector;
  }

  // Subtraction
  static public FVector Subtract( FVector vector1, FVector vector2 ){                  // Returns the subtraction of vector1 and vector2.
    FVector newVector = vector1.ReturnNewInstance();
    newVector.Subtract( vector2 );
    return newVector;
  }

  // Multiplication
  static public FVector Multiply( FVector vector, float d ){                           // Returns a vector that has been multiplied by d.
    FVector newVector = vector.ReturnNewInstance();
    newVector.Multiply( d );
    return newVector;
  }

  // Division
  static public FVector Divide( FVector vector, float d ){                             // Returns a vector that has been divided by d.
    FVector newVector = vector.ReturnNewInstance();
    newVector.Divide( d );
    return newVector;
  }

  //  ----  ----  RETURN METHODS  ----  ----
  // Angle
  static public float GetAngle( FVector vector1, FVector vector2 ){
    float scalarProduct = GetScalarProduct( vector1, vector2 );
    float cosinus = scalarProduct / ( vector1.GetMagnitude() * vector2.GetMagnitude() );
    float angle = acos( cosinus );

    return angle;
  }
  
  // Magnitude
  static public float GetMagnitude( FVector vector ){
    return vector.GetMagnitude();                       // Returns the magnitude (length) of the inputed vector.
  }

  // Scalar product
  static public float GetScalarProduct( FVector vector1, FVector vector2 ){            // Returns the scalar product of two vectors.
    return vector1.GetScalarProduct( vector2 );
  }

  // Projection
  static public FVector GetProjectionVector( FVector vector1, FVector vector2 ){
    FVector newProjVector = vector1.ReturnNewInstance();
    newProjVector.Project( vector2 );
    return newProjVector;
  }

  // Is the same vector'
  static public boolean IsTheSameVector( FVector vector1, FVector vector2 ){
    if( vector1.x == vector2.x && vector1.y == vector2.y ){ return true; }
    return false;
  }


}
class GameEngine{
    // Engines
    private PhysicsEngine   phE;
    private PaintEngine     pE;

    // Entities
    private ArrayList<Entity>           fruits;
    private ArrayList<Entity_Sprite>    sprites;
    private Entity_Snake                snake;

    // INFO about play area
    private boolean[][] inhabitedCells;

    // gameSettings pointers
    private int res;

    // Start-up settings
    private int score;

    // FLAGS
    private boolean pause               = false;
    private boolean gameOver            = false;
    private boolean quit                = false;

    // GameEngine CONSTRUCTOR
    public GameEngine(){
        this.phE = new PhysicsEngine();              // Initializing engines.
        this.pE  = new PaintEngine();

        this.fruits  = new ArrayList<Entity>();       // Initializing entity arrays.
        this.sprites = new ArrayList<Entity_Sprite>();

        this.res = gameSettings.playAreaResolution;  // Retrieving variables from gameSettings.

        this.score = 0;                              // Start-up settings.
        
        this.inhabitedCells = new boolean[ this.res ][ this.res ];                 // Makes all cells uninhabited for the beginning.
        for( int y = 0; y < this.res; y++ ){
            for( int x = 0; x < this.res; x++ ){
                this.inhabitedCells[ x ][ y ] = false;
            }
        }

        this.snake =  new Entity_Snake( "Snake", 3, 6, MOVELEFT );       // Creating our player (a Entity_Snake object).

        for( int i = 0; i < gameSettings.FruitsPerPlayArea(); i++ ){  // Filling play area with the fruits.
            this.fruits.add( MakeFruit() );
        }
    }

    public void CountDown(){
        // pE.CountDown();
    }

    /** 
     Main method for GameEngine. Updates the games engines (physics engine and painengine),
     checks for collisions and refills play area with fruits.
    */
    public void UpdateGame(){
        phE.UpdateEntityPhysics( this.snake, this.fruits, this.pause );
        pE.DrawPlayArea();
        if( gameSettings.LoopMovement() ){ pE.DrawPlayAreaOutOfBounds(); }
        pE.DrawEntities( this.snake, this.fruits, this.sprites, this.phE.ReturnClockCycle(), this.phE.ReturnSnakeClockCycle(), this.pause );
        pE.DrawGameScore();

        if( this.gameOver ){
            pE.DrawGameOver( this.phE.ReturnClockCycle() );
        }

        if( CheckSnakeCollision() ){
            this.gameOver   = true;
            this.pause      = true;
        }

        if( phE.CheckFruitCollision( snake, fruits ) ){
            this.score += 10;
            if( this.score % 50 == 0 ){
                println("SNAKE: SPEEDING UP!");
                gameSettings.snakeClockRate -= 2;
            }
            this.snake.AddToSnakeBody();
        }

        if( fruits.size() < gameSettings.FruitsPerPlayArea() ){
            this.fruits.add( MakeFruit() );
        }
    }

    /**
     Adds a fruit to any unhabited cells in the play area.
    */
    private Entity_Fruit MakeFruit(){
        CheckIC();                                  // Rechecks play area for inhabited cells.

        int x =  PApplet.parseInt( random( res ) );              // Creates a random set of coordinates in
        int y =  PApplet.parseInt( random( res ) );              // the play area.

        while( true ){                              // Loops and makes new random coordinates
            if( this.inhabitedCells[ x ][ y ] ){         // until they dont match any occupied
                x = PApplet.parseInt ( random( res ) );          // cells.
                y = PApplet.parseInt ( random( res ) );
            }
            else{ break; }
        }

        this.inhabitedCells[ x ][ y ] = true;            // Sets the coordinates cell to 'occupied'

        return new Entity_Fruit( "Apple", x, y );
    }

    private boolean CheckSnakeCollision(){
        if( this.snake.HeadCollision() ){
            return true;
        }
        return false;
    }

    private void CheckSprites(){
        for( int i = 0; i < this.sprites.size(); i++ ){
            if( sprites.get( i ).IsExpired() ){
                sprites.remove( i );
            }
        }
    }



    /**
     Checks the play area for all occupied cells and updates
     the 'inhabitedCells' arrayList.
    */
    private void CheckIC(){
        ICClear();
        ICCheckSnake();
        ICCheckFruits();
    }

    /**
     Clears the 'inhabitedCells' arrayList by setting all
     indexes to false.
    */
    private void ICClear(){
        for( int y = 0; y < this.res; y++ ){
            for( int x = 0; x < this.res; x++ ){
                this.inhabitedCells[x][y] = false;
            }
        }
    }
    
    /**
     Adds the cells that the snake occupies to the arrayList.
    */
    private void ICCheckSnake(){
        for( int y = 0; y < this.res; y++ ){
            for( int x = 0; x < this.res; x++ ){
                if( this.snake.DoesCollideSnake( new FVector( x, y ) ) ){
                    this.inhabitedCells[x][y] = true;
                }
            }
        }
    }

    /**
     Adds the cells that the fruits occupies to the arrayList.
    */
    private void ICCheckFruits(){
        for( int y = 0; y < this.res; y++ ){
            for( int x = 0; x < this.res; x++ ){
                if( CollideWithFruit( new FVector( x, y ) ) ){
                    this.inhabitedCells[x][y] = true;
                }
            }
        }
    }

    /**
     Checks if a given vector collides with any fruits at the 
     same position.
    */
    private boolean CollideWithFruit( FVector vector ){
        for( Entity f : this.fruits ){
            if( vector.IsTheSame( f.GetPosition() ) ){
                return true;
            }
        }
        return false;
    }



    /**
     Accesses the snake entity and turns it right.
    */
    public void TurnSnakeRight(){
        this.snake.UpdateVelocityRight();
    }

    /**
     Accesses the snake entity and turns it left.
    */
    public void TurnSnakeLeft(){
        this.snake.UpdateVelocityLeft();
    }

    /**
    Adds to the length of the snake entity.
    */
    public void AddSnakeBody(){
        this.snake.AddToSnakeBody();
    }



    public void AddSprite( Entity_Sprite sprite ){
        this.sprites.add( sprite );
    }



    /**
    Pauses the game by disabling physics updates.
    */
    public void TogglePause(){
        if( !this.gameOver ){
            this.pause = !this.pause;
        }
    }



    // Return methods
    public float ReturnClockCycle(){
        return this.phE.ReturnClockCycle();
    }

    // PROPERTIES
    public boolean Quit(){ return this.quit; }
    public boolean GameOver(){ return this.gameOver; }
}
class GameSettings{
    // Settings
    private int         gameWindowSize, gameWindowWidth;
    public final int    playAreaResolution  = 10;
    public final int    frames              = 5;

    // Game Settings
    private int     fruitsPerPlayArea   = 3;
    private boolean loopMovement        = true;
    public  int     gameClockRate       = 380;  // Default 380

    // the snake goes back a frame, some kind of bug

    // Color settings
    public final int  BACKCOLOR        = 0xFF1D1B1C;
    public final int  PLAYAREACOLOR    = 0xFFDCE2BD;
    public final int  PLAYSQUARECOLOR  = 0xFFD4CDAB;

    // Automated settings
    public float playAreaSize, playAreaOffsetX, playAreaOffsetY, squareSize;
    public int     snakeClockRate      = gameClockRate; 

    public GameSettings(){
        this.gameWindowSize     = height;
        this.gameWindowWidth    = width;

        this.squareSize     = floor( ( PApplet.parseFloat(this.gameWindowSize) * 0.8f ) / ( PApplet.parseFloat(this.playAreaResolution) * 10f ) ) * 10f;
        this.playAreaSize   = this.squareSize * this.playAreaResolution;


        this.playAreaOffsetX = ( this.gameWindowWidth - playAreaSize ) / 2f;
        this.playAreaOffsetY = ( this.gameWindowSize - playAreaSize ) / 2f;
    }

    // Methods
    public boolean OutOfBounds( FVector min, FVector max, FVector vector ){
        if( vector.x >= min.x && vector.x <= max.x && vector.y >= min.y && vector.y <= max.y ){
            return true;
        }
        return false;
    }

    public float IndexToPosition( float i ){
        return i * squareSize;
    }

    // Scales a vector by the square size.
    public void ScaleFVector( FVector vector ){
        vector.Multiply( squareSize );
    }

    public int CorrectInt( int i ){
        int res = playAreaResolution;
        if( i < 0 ){ i += res; }
        if( i >= res ){ i -= res; }
        return i;
    }

    // Corrects a vector so that its length doesn't go past 1 unit.
    public FVector CorrectFVector( FVector vector ){
        int res = playAreaResolution;
        FVector newVector = vector.ReturnNewInstance();
        if( newVector.GetMagnitude() > 1f ){
            if( vector.x < -1f ){ vector.x += res; }
            else if( vector.x >  1f ){ vector.x -= res; }
            if( vector.y < -1f ){ vector.y += res; }
            else if( vector.y >  1f ){ vector.y -= res; }
        }

        return vector;
    }


    // PROPERTIES
    public int  GameWindowSize(){ return this.gameWindowSize; }
    public void GameWindowSize( int gameWindowSize ){ this.gameWindowSize = gameWindowSize; }
    
    public int  GameWindowWidth(){ return this.gameWindowWidth; }
    public void GameWindowWidth( int gameWindowWidth ){ this.gameWindowWidth = gameWindowWidth; }

    public int  GameClockRate(){ return this.gameClockRate; }
    public void GameClockRate( int gameClockRate ){ this.gameClockRate = gameClockRate; }
    
    public boolean  LoopMovement(){ return this.loopMovement; }
    public void     LoopMovement( boolean loopMovement ){ this.loopMovement = loopMovement; }
    
    public int  FruitsPerPlayArea(){ return this.fruitsPerPlayArea; }
    public void FruitsPerPlayArea( int fruitsPerPlayArea ){ this.fruitsPerPlayArea = fruitsPerPlayArea; }
}
class PaintEngine{
    private int currentFrame, lastFrame;
    private PFont mono;

    private int snakeClockRate = gameSettings.GameClockRate();
    private float snakeClockCycle;
    private int snakeFrame;

    private int acceleration = 0;

    // GameOver variables
    private float   gameOverAlpha       = 0;
    private float   fadeOutAlpha        = 0;
    private float   scoreAlpha          = 0;
    private float   startOverAlpha      = 0;
    private float   scoreTextSize       = 120;
    private float   gameOverTextSize    = 190;
    private int     textSizeEnd         = PApplet.parseInt( gameSettings.playAreaSize / 10 );
    private int     gameOverWaitingTime = 3000;
    private boolean drawFadeOut         = true;
    private boolean drawGameScore       = false;
    private boolean drawRestart         = false;
    private boolean drawGameOverText    = false;

    private long    lastUpdate;
    private long    lastSnakeUpdate;
    private boolean replay = false;
    private boolean stop    = false;
    private int     frame;

    //  ----    ----    PaintEngine CONSTRUCTOR     ----    ----
    public PaintEngine(){
        mono            = createFont( "Cafe Matcha.ttf", 40 );
        lastFrame       = 1;
        lastUpdate      = millis();
        lastSnakeUpdate = millis();
        frame = 1;
    }

    // Creating a countdown for when the game starts.
    // public void CountDown(){
    //     if( millis() - lastUpdate )
    // }

    //  ----    ----    Drawing Methods     ----    ----
    public void DrawEntities( Entity_Snake snake, ArrayList<Entity> fruits, ArrayList<Entity_Sprite> sprites, float clockCycle, float snakeClockCycle, boolean pause ){      
        this.currentFrame   = ceil( gameSettings.frames * clockCycle );         // Sets the current frame in sync with the gameClockCycle
        this.snakeFrame     = ceil( gameSettings.frames * snakeClockCycle );    // Sets the current frmae in sync with the snakeClockCycle, as to only speed up the snake frame rate.
        
        // Making sure no "illegal" frames are created.
        if( this.snakeFrame > 5 ){ this.snakeFrame = 5; }
        if( this.snakeFrame < 1 ){ this.snakeFrame = 1; }

        if( this.currentFrame > 5 ){ this.currentFrame = 5; }
        if( this.currentFrame < 1 ){ this.currentFrame = 1; }

        // Translating canvas and pushing matrix.
        pushMatrix();
        translate( gameSettings.playAreaOffsetX, gameSettings.playAreaOffsetY );

        // Drawing all sprites and fruits.
        for( Entity_Sprite e : sprites ){
            e.Draw( this.currentFrame );
        }
        for( Entity e : fruits ){
            e.Draw( this.currentFrame );
        }

        // Script for stopping snake at its current frame when game has paused.
        frame = currentFrame;
        if( pause ){
            if( frame == 5 ){
                frame = this.lastFrame;
                stop = true;
            }
        }
        else if( this.lastFrame == this.currentFrame ){
            this.lastFrame = frame;
            stop = false;
        }

        // Drawing snake, and if paused draws it at the last frame.
        if( stop ){ 
            snake.Draw( 5 );
        }
        else{
            snake.Draw( snakeFrame );
        }

        // Draws a black border around the playarea.
        stroke( 255 );
        strokeWeight( 2 );
        noFill();
        rect( 0, 0, gameSettings.playAreaSize, gameSettings.playAreaSize );
    
        popMatrix();
        noTint();

        if( !pause ){
            this.lastFrame = currentFrame;
            lastUpdate = millis();
        }
    }

    // Methods for drawing the play area.
    public void DrawPlayArea(){                                             // Draws the play area.
        pushMatrix();

        rectMode( CORNER );
        translate( gameSettings.playAreaOffsetX, gameSettings.playAreaOffsetY );

        // Draws checker-pattern playearea.
        DrawPlayAreaBack( gameSettings.playAreaSize );
        DrawPlayAreaSquares( gameSettings.squareSize, gameSettings.playAreaResolution );

        popMatrix();
    }

    // Draws the backdrop of the play area. 
    private void DrawPlayAreaBack( float size ){                            
        pushMatrix();
        fill( gameSettings.PLAYAREACOLOR );
        noStroke();
        rect( 0, 0, size, size );
        popMatrix();
    }

    private void DrawPlayAreaSquares( float size, float res ){              // Draws the checkboard pattern of squares on the play area.
        
        pushMatrix();

        for( int i = 1; i <= res; i++ ){
            pushMatrix();
            for( int j = 1; j <= res; j++ ){
                if( i % 2 == 0 && j % 2 == 0 ){         // CHECKS IF THE COORDINATES ARE EVEN.
                    DrawPlayAreaSquare( size );
                }
                else if( i % 2 != 0 && j % 2 != 0 ){    // CHECKS IF THE COORDINATES ARE UNEVEN.
                    DrawPlayAreaSquare( size );
                }

                translate( size, 0 );
            }
            popMatrix();

            translate( 0, size );
        }

        popMatrix();
    }

    private void DrawPlayAreaOutOfBounds(){
        pushMatrix();
        for( int i = 0; i < gameSettings.playAreaResolution; i++ ){
            for( int j = 0; j < 3; j++ ){
                if( i % 2 !=  j % 2 ){ continue; }

                fill( 210, 50 - 20*j );
                rect(
                    gameSettings.playAreaOffsetX - gameSettings.squareSize * (j + 1),
                    gameSettings.playAreaOffsetY + gameSettings.squareSize * i,
                    gameSettings.squareSize, gameSettings.squareSize
                );
                rect(
                    gameSettings.playAreaOffsetX + gameSettings.playAreaSize + gameSettings.squareSize * j,
                    gameSettings.playAreaOffsetY + gameSettings.squareSize * i,
                    gameSettings.squareSize, gameSettings.squareSize
                );

                rect(
                    gameSettings.playAreaOffsetX + gameSettings.squareSize * i,
                    gameSettings.playAreaOffsetY - gameSettings.squareSize * (j+1),
                    gameSettings.squareSize, gameSettings.squareSize
                );
                rect(
                    gameSettings.playAreaOffsetX + gameSettings.squareSize * i,
                    gameSettings.playAreaOffsetY + gameSettings.playAreaSize + gameSettings.squareSize * j,
                    gameSettings.squareSize, gameSettings.squareSize
                );
            }
        }
        popMatrix();
    }

    private void DrawPlayAreaSquare( float size ){                          // Draws one square in the play area.
        pushMatrix();
        fill( gameSettings.PLAYSQUARECOLOR );
        noStroke();
        rect( 0, 0, size, size );
        popMatrix();
    }

    public void DrawGameScore(){
        float x = gameSettings.GameWindowWidth() / 2;
        float y = gameSettings.playAreaOffsetY / 2 + 10;
        textSize( 40 );
        DrawText( "SCORE: " + nf( gE.score, 3 ), x, y, 40, color( 210, 255 - this.fadeOutAlpha ) );
    }

    private void DrawText( String text, float x, float y, int size, int fillColor ){
        fill( 200 );
        noStroke();
        textAlign( CENTER );
        fill( fillColor );
        textFont( this.mono, size );
        text( text, x, y );
    }

    public void DrawGameOver( float clockCycle ){
        if( millis() - this.lastUpdate >= this.gameOverWaitingTime ){
            if( this.fadeOutAlpha < 209.9f ){
                this.fadeOutAlpha = Lerp( this.fadeOutAlpha, 210, 0.2f );
            }
            else if( this.gameOverAlpha < 254.9f ){
                this.drawGameOverText   = true;
                this.gameOverAlpha      = Lerp( this.gameOverAlpha, 255, 0.5f );
                this.gameOverTextSize   = Lerp( this.gameOverTextSize, this.textSizeEnd + 60, 0.5f );
            }
            else if( this.scoreAlpha < 254.9f ){
                this.drawGameScore  = true;
                this.scoreAlpha     = Lerp( this.scoreAlpha, 255, 0.5f );
                this.scoreTextSize  = Lerp( this.scoreTextSize, this.textSizeEnd + 20, 0.5f );
            }
            else if( this.startOverAlpha < 254.9f ){
                this.drawRestart    = true;
                this.startOverAlpha = Lerp( this.startOverAlpha, 255, 0.8f );
            }
            else{
                this.gameOverWaitingTime    = 1000;
            }
            this.gameOverWaitingTime = 30;
            this.lastUpdate = millis();
        }
        fill( 0, this.fadeOutAlpha );
        rect( gameSettings.playAreaOffsetX, gameSettings.playAreaOffsetY, gameSettings.playAreaSize, gameSettings.playAreaSize );
        if( this.drawGameOverText ){
            float x = gameSettings.GameWindowWidth() / 2;
            float y = gameSettings.GameWindowSize() / 2;

            DrawText( "GAME OVER.", x, 3f*y/4f, PApplet.parseInt(this.gameOverTextSize), color( 255, 70, 70, this.gameOverAlpha ) );

            if( this.drawGameScore ){
                DrawText( "FINAL SCORE: " + nf( gE.score, 3 ), x, y, PApplet.parseInt(this.scoreTextSize), color( 255, this.scoreAlpha) );

                if( this.drawRestart ){
                    DrawText( "Press 'r' to restart with current settingss, or 'm' to return to the menu", x, y + 0.5f*y, 20, color( 255, this.startOverAlpha ) );
                }
            }
        }
    }

    private void SpeedUpSnake( int b ){
        this.acceleration += b;
    }

    // Return methods
    public int ReturnCurrentFrame(){
        return currentFrame;
    }
}
class PhysicsEngine{
  private int dt;
  private long lastUpdate, lastSnakeUpdate, currentUpdate;
  private long gameClock, snakeClock;

  // Default PhysicsEngine CONSTRUCTOR
  public PhysicsEngine(){
    dt = gameSettings.GameClockRate();
    lastUpdate = millis();
  }

  // PhysicsEngine CONSTRUCTOR
  public PhysicsEngine( int dt ){
    this.dt = dt;
    lastUpdate = millis();
  }

  // Updating physics of entities
  public void UpdateEntityPhysics( Entity_Snake snake, ArrayList<Entity> entities, boolean pause ){
    currentUpdate = millis();                       // Sets the start time for this loop.
    gameClock     = currentUpdate - lastUpdate;       // Calculates the gameClock time.
    snakeClock    = currentUpdate - lastSnakeUpdate;
    dt            = gameSettings.GameClockRate();

    if( gameClock >= dt ){
      if( !pause ){
        for( Entity e : entities ){                   // Loops through the passed entities[] argument and updates their physics bodies.
          if( e instanceof IntPhysicsBody ){
            ( (IntPhysicsBody)e ).UpdatePhysics( );
          }
        }
      }

      lastUpdate = currentUpdate;                   // Sets the last update to the start time of this loop.
    }

    if( snakeClock > gameSettings.snakeClockRate ){
      if( !pause ){
        snake.UpdatePhysics();
      }

      lastSnakeUpdate = currentUpdate;
    }
  }

  // Return methods
  public float ReturnClockCycle(){
    return (millis() - lastUpdate) / PApplet.parseFloat(dt);
  }

  public float ReturnSnakeClockCycle(){
    return (millis() - lastSnakeUpdate) / PApplet.parseFloat(dt);
  }

  public boolean CheckFruitCollision( Entity_Snake snake, ArrayList<Entity> entities ){
    for( int i = 0; i < entities.size(); i++ ){
      if( entities.get( i ) instanceof Entity_Fruit ){
        if(  FVectorMath.IsTheSameVector( entities.get( i ).GetPosition(), snake.GetPosition() ) ){
          entities.remove( i );
          return true;
        }
      }
    }
    return false;
  }
}
class Sprite{
    private PImage[]    images;
    private int         frames;
    private String      spriteName;

    // Sprite CONSTRUCTOR
    public Sprite( String spriteDirectory, String spriteName ){
        this.spriteName = spriteName;
        this.frames     = gameSettings.frames;
        this.images     = new PImage[ frames ];

        for( int i = 0; i < this.frames; i++ ){
            this.images[i] = loadImage( "data/sprites/" + spriteDirectory + "/" + this.spriteName + nf( i + 1, 2 ) + ".png" );
        }
    }

    /**
     Draws a sprite on the canvas.
     @args frame    the frame to draw the sprite at
     @args position the position to draw the sprite at
     @args rotation the rotation of the sprite
     @args flip     if true, flips the sprite image
     */
    public void DrawSprite( int frame, FVector position, float scale, float rotation, boolean flip ){    // Draws a snake block.
        float sS = gameSettings.squareSize;

        pushMatrix();

        float x = gameSettings.IndexToPosition( position.x ) + sS/2f;
        float y = gameSettings.IndexToPosition( position.y ) + sS/2f;
        translate( x, y );

        // Drawing the sprite
        scale( scale, scale );
        if( flip ){ scale( -1, 1 ); }
        rotate( rotation );
        image( this.images[ frame - 1 ], -sS/2f, -sS/2f, sS,sS );

        popMatrix();
    }

    // Returns the name
    public String SpriteName(){
        return this.spriteName;
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
